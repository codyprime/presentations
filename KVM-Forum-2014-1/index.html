<!doctype html>
<html lang="en">

<head>
<meta charset="utf-8">

<title>New to QEMU: A Developer's Guide to Contributing</title>

<meta name="author" content="Jeff Cody">

<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<link rel="stylesheet" href="css/reveal.min.css">
<link rel="stylesheet" href="css/theme/jtc-redhat.css" id="theme">

<!-- For syntax highlighting -->
<link rel="stylesheet" href="lib/css/zenburn.css">

<!-- If the query includes 'print-pdf', use the PDF print sheet -->
<script>
document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
</script>

<!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
</head>

<body>

<div class="reveal">
    <div id="header-white">
        <center>
            <h2>New to QEMU:</h2>
            <h4>A Developer's Guide to Contributing</h4>
            <small>
                Jeff Cody | <a href="mailto:jcody@redhat.com"> jcody@redhat.com </a>
            </small>
        </center>
    </div>


    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section data-state="header-visible"
                 data-background-video="../resources/videos/qemu-gource-stream.mp4"
                 data-background-video-loop="true"
                 data-background="#111111" class="videoback">

        </section>

        <section>
            <section>
                <h2>First, some background on Block Drivers</h2>
            </section>
            <section>
            <h2>What Is A Block Driver?</h2>
            <p>
            A <code>QEMU</code> block driver provides storage on the host, that the guest sees as a drive.
            </p>
            <br>
            <p>In the QEMU code, they are located in the <code>block/</code> directory.</p>
            </section>

            <section>
            <h2>The two major block driver types in QEMU</h2>
            <p>
            <ul>
            <li>Image format drivers</li>
            <li>Protocol based drivers</li>
            </ul>
            </p>
            </section>

            <section>
            <h2>Image Format Drivers</h2>
            <p>
            Provide a structured way to store data, often with built-in features (such as snapshots, data sparseness, drive metadata, etc..).&nbsp;&nbsp;<br>
            <br>
            <b>Examples</b>
            </p>
            <div style="align: left; background: #fffff0">
            <p style="align: left">
            <ul style="align: left">
                <li style="align: left">QCOW2</li>
                <li style="align: left">QED</li>
                <li style="align: left">raw</li>
                <li style="align: left">etc.</li>
            </ul>
            </p>
            </div>
            </section>

            <section>
            <h2>Protocol based drivers: </h2>
            <p>
            Provides the underlying data I/O for image formats, although may also be a stand-alone driver as well. &nbsp;&nbsp;
            <br>
            <br> Examples include:
            </p>
            <div>
                <div style="width: 50%; background:#fffff0; float: left; padding-bottom: 100%; margin-bottom: -100%" class="fragment">
                    <p>
                    <b>Network-based protocols drivers in QEMU: </b>
                    <ul>
                        <li>Gluster</li>
                        <li>iSCSI</li>
                        <li>NBD</li>
                        <li>etc.</li>
                    </ul>
                    </p>
                </div>
                <div style="width: 50%; background:#f0f0ff; float: right; padding-bottom: 100%; margin-bottom: -100%" class="fragment">
                    <p>
                    <b>Host protocols drivers in QEMU: </b>
                    <ul>
                        <li>raw-posix files</li>
                        <li>raw-posix host devices</li>
                        <li>etc.</li>
                    </ul>
                    </p>
                </div>
            </div>
            </section>

            <section>
                <h2> The BlockDriver struct </h2>
                <p> The <code><a href=https://github.com/qemu/qemu/blob/v1.6.0/include/block/block_int.h#L83>BlockDriver</a></code> struct contains the block-layer internal API to the format driver.&nbsp;&nbsp; It consists mainly of function pointers, used to interface with the driver. </p>
                <ul>
                    <li><code>.bdrv_open</code></li>
                    <li><code>.bdrv_co_readv</code></li>
                    <li><code>etc..</code></li>
                </ul>
                <br>
                <br>
                <p class="fragment"> We'll get into these more later.
                </p>
            </section>
         </section>

         <section>
             <h2> Core Concepts </h2>
             <ul>
                 <li> Probing </li>
                 <li> Open and Reopen </li>
                 <li> Coroutines, and Read / Write </li>
                 <li> Metadata Caching </li>
                 <li> Image Creation </li>
                 <li> Data Handling </li>
                 <li> Backing Files </li>
                 <li> Testing </li>
             </ul>
         </section>
         <section data-background-image="../resources/images/rh-background-dark-nologo-ufo.png">
             <section>
                 <h2 class="alt">The Probe</h2>
                 <div style="color: #ffffff">
                 <center>
                 Driver is passed first 2048 bytes
             </center>
                 <br>
                 <div class="fragment">
                 <pre class="alt"><code class="alt" data-trim contenteditable>
00000000  76 68 64 78 66 69 6c 65  51 00 45 00 4d 00 55 00  |vhdxfileQ.E.M.U.|
00000010  20 00 76 00 31 00 2e 00  36 00 2e 00 35 00 30 00  | .v.1...6...5.0.|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
                 </code></pre>
                 <div style="color: #ffffff">VHDX</div>
             </div>
                 <br>
                 <div class="fragment">
                 <pre class="alt"><code class="alt" data-trim contenteditable>
00000000  51 46 49 fb 00 00 00 02  00 00 00 00 00 00 00 b8  |QFI.............|
                 </code></pre>
                 QCOW2
             </div>
                 <br>
                 <br>
                 <div class="fragment">
                 <p style="color: #ffffff">
                 <ul style="color: #ffffff">
                     <li> If first 2K is not enough, probe won't work. </li>
                     <li> Return a confidence score from 0-100.  </li>
                 </ul>
                 </p>
             </div>
             </div>
             </section>
             <section>
                 <h2 class="alt">The Probe</h2>

                 <pre class="alt"><code class="alt" data-trim contenteditable>
static int qcow2_probe(const uint8_t *buf, int buf_size, const char *filename)
{
    const QCowHeader *cow_header = (const void *)buf;

    if (buf_size >= sizeof(QCowHeader) &&
        be32_to_cpu(cow_header->magic) == QCOW_MAGIC &&
        be32_to_cpu(cow_header->version) >= 2)
        return 100;
    else
        return 0;
}
                 </code></pre>
             </section>
        </section>
         <section>
             <section>
                 <h2>The BlockDriver Open Flow</h2>
                 <p>
                 (Simplified view, as relevant to an Image Format Driver)
                 </p>
                 <a href="../resources/images/SimpleOpenFlow.png"><img src="../resources/images/SimpleOpenFlow.png"  height="100%"></a>
                 <p>
                 </p>
             </section>

             <section>
                 <h2> Let's Jump In </h2>
                 <h3> Implementing a (very basic!) Image Format Driver </h3>
             </section>

             <section>
                 <h2> Creating a new format - the "silly" format </h2>
                 <p> At the minimum, we need: </p>
                 <ul>
                     <li> block_init(), for our driver to be seen </li>
                     <li> To define our BlockDriver, and register it via bdrv_register() </li>
                     <li> A format name (ours is "silly") </li>
                     <li> In our BlockDriver, we must at least have a &nbsp; .bdrv_open() implementation </li>
                 </ul>
                 <br>
                 <br>
                 <br>
                 <br>
                 <br>
                 <p class="fragment">
                 Let's see this as code.
                 </p>
             </section>
             <section>
                 <pre class="alt"><code class="alt" data-trim contenteditable>
#include "block/block_int.h"

/* Our open function */
static int silly_open(BlockDriverState *bs, QDict *options, int flags,
                      Error **errp)
{
    return 0;
}

/* Our attributes / functions */
static BlockDriver bdrv_silly = {
    .format_name    = "silly",
    .bdrv_open      = silly_open
};

/* register our BlockDrivers */
static void bdrv_silly_init(void)
{
    bdrv_register(&bdrv_silly);
}

/* macro magic, creates an init function */
block_init(bdrv_silly_init);
                 </code></pre>
             </section>

         </section>


         <section>
            <section>
                <h2> Your Driver's Stateful Data </h2>
                <p>
                Most Block Drivers require state data, populated on open.
                </p>
                <ul>
                    <li> Provided via BlockDriverState .opaque field </li>
                    <li> Size is specified in  BlockDriver struct, &nbsp;.instance_size </li>
                    <li> Not allocated by your driver, but by the block layer </li>
                </ul>
                <br>
                <br>
                <p>
                The BlockDriverState struct is passed to most functions.  The "opaque" field is for your driver's internal data.
                </p>
            </section>
            <section>
                <h2> What your open must provide </h2>
                <p>
                At a minimum, your .bdrv_open must:
                </p>
                <ul>
                    <li> Verify the integrity of the image, if relevant </li>
                    <li> Populate your internal state data ("opaque") </li>
                    <li> Total sectors, if relevant for your driver </li>
                </ul>
            </section>
            <section>
                <h2> Reopen functionality </h2>
                <p> Reopen allows QEMU to open an image chain with different flags
                <ul>
                    <li> Live snapshots </li>
                    <li> Block commit </li>
                    <li> etc.. </li>
                </ul></p>
                <br>
                <div class="fragment">
                <p> Reopen has three hooks:
                <ul>
                    <li>  Prepare (.bdrv_reopen_prepare) </li>
                    <li>  Commit (.bdrv_reopen_commit) </li>
                    <li>  Abort (.bdrv_reopen_abort) </li>
            </ul></p></div>
            </section>
            <section>
                <h2> Reopen functionality </h2>
                <br>
                <align left>
                <p> <code>.bdrv_reopen_prepare()</code>, required if reopen supported
                <ul>
                    <li> Returns 0 for success - stub OK</li>
                    <li> Protocols will likely have more to do</li>
                </ul>  </p>
                <br>
                <p> Depending on what your driver needs to support reopen, you may also need to provide the commit and abort functions, but these are optional <p>
            </section>
        </section>

        <section>
            <section>
                <h2>Coroutines, and Read / Write</h2>
                <p>
                Block driver read / write operations all make use of coroutines
                </p>
            </section>
            <section>
                <h2>What are coroutines?</h2>
                <p>Coroutines allow asynchronous code to masquerade as synchronous code</p>
                <br>
                <p>(Despite sounding complex, this makes life easier for you!)</p>
                <br>
                <p>Control stays with your coroutine until you either yield, or return</p>
            </section>
            <section>
                <h2>How does my driver use coroutines?</h2>
                <p><ul>
                    <li> Take CoMutex when needed (<code>qemu_co_mutex_lock</code>)</li>
                    <li> Yield if needed (<code>qemu_coroutine_yeild()</code>)
                    <li class="fragment"> Everything uses coroutines </li>
                </ul>
            </section>
             <section>
                 <h2>The BlockDriver Read Flow</h2>
                 <p>
                 Simplied read flow, for an Image Format driver using I/O vectors
                 </p>
                 <a href="../resources/images/ReadFlow.png"><img src="../resources/images/ReadFlow.png"  height="100%"></a>
                 <p>
                 </p>
             </section>
             <section>
                 <h2>The BlockDriver Write Flow</h2>
                 <p>
                 Simplied write flow, for an Image Format driver using I/O vectors
                 </p>
                 <a href="../resources/images/WriteFlow.png"><img src="../resources/images/WriteFlow.png"  height="100%"></a>
                 <p>
                 </p>
             </section>
        </section>

        <section>
            <section>
            <h2>Metadata Caching</h2>
            <p style="align: center">
            <center> Block Drivers will often cache image format metadata</center>
            </p>
            <br>
            <br>
            <div class="fragment">
            <p><b>This can cause problems</b></p>
            <p>
            During Live Migration, the image format metadata may differ from your cache.
            </p>
        </div>
            </section>
            <section>
            <h2>Metadata Cache Flushing</h2>
            <p>
            You can either invalidate the metadata when requested, or prevent migration
            </p>
            <br>
            <p>
            <div class="fragment">
            <ul>
                <li> .bdrv_invalidate_cache() </li>
                <li> migrate_add_blocker() </li>
            </ul>
            </div>
            </section>
        </section>

        <section>
            <h2>BlockDriver Image File Creation</h2>
            <br><br><br>
            <ul>
                <li> Implement .bdrv_create() </li>
                <div class="fragment">
                <li> Define QEMUOptionParameter </li>
                    <div style="width: 50%; background: #f0f0f0; float: left"> Size</div> <div style="width: 50%; background: #fffff0; float: right"> OPT_SIZE </div>
                    <div style="width: 50%; background: #f0f0f0; float: left"> String</div> <div style="width: 50%; background: #fffff0; float: right"> OPT_STRING </div>
                    <div style="width: 50%; background: #f0f0f0; float: left"> Flag</div> <div style="width: 50%; background: #fffff0; float: right"> OPT_FLAG </div>
                    <div style="width: 50%; background: #f0f0f0; float: left"> Number</div> <div style="width: 50%; background: #fffff0; float: right"> OPT_NUMBER </div>
            </ul>
        </section>

        <section>
            <h2> Sample BlockDriver Struct </h2>
                 <pre class="alt"><code class="alt" data-trim contenteditable>
static BlockDriver bdrv_qcow2 = {
    .format_name          = "qcow2",
    .instance_size        = sizeof(BDRVQcowState),
    .bdrv_probe           = qcow2_probe,
    .bdrv_open            = qcow2_open,
    .bdrv_close           = qcow2_close,
    .bdrv_reopen_prepare  = qcow2_reopen_prepare,
    .bdrv_create          = qcow2_create,

/* snipped */

    .bdrv_co_readv          = qcow2_co_readv,
    .bdrv_co_writev         = qcow2_co_writev,
    .bdrv_co_flush_to_os    = qcow2_co_flush_to_os,

/* more snipped */
    .create_options = qcow2_create_options,
};  
                 </code></pre>
        </section>
        <section>
            <section>
                <h2> Data Handling </h2>
                <p> If you are reading or writing data structures from / to disk, please: </b>
                <ul>
                    <li> Don't trust it </li>
                    <li> Do pack it </li>
                    <li> Do convert endian </li>
                </ul>
            </section>
            <section>
                <h2> Don't Trust That Data </h2>
                <p> Unvalidated data can be security risks: </p>
                <ul>
                    <li> We don't want to allocate more memory than expected (DoS) </li>
                    <li> We don't want to read / write past buffers (overflows) </li>
                    <li> We don't want to crash QEMU </li>
                </ul>
            </section>
            <section>
                <h2> Packing and Endian conversion </h2>
                <p> Make sure that your driver will work on all platforms </p>
                <ul>
                    <li> Use QEMU_PACKED on structures read/written from disk </li>
                    <li> Convert endiannes for on-disk fields </li>
                </ul>
                <br>
                <br>
                <p> If you don't do this, your driver may work fine on your system.
                <ul>
                    <li>  But maybe not other systems </li>
                </ul> </p>
            </section>
        </section>

        <section> 
            <section>
                <h2> Backing Files </h2>
                    <ul>
                        <li>Populate bs->backing_file</li>
                        <li>Implement <code>.bdrv_co_get_block_status</code></li>
                    </ul>
            </section>
        </section>

        <section> 
            <section>
                <h2> Testing </h2>
                <ul>
                    <li>Use qemu-iotests</li>
                    <ul>
                        <li> Create test in tests/qemu-iotests </li>
                        <li> Bash or Python </li>
                        <li> Put test in 0##, and expected output in 0##.out </li>
                    </ul>
                    <br>
                    <li>Sample Images</li>
                    <ul>
                        <li> For a compatibility driver, test against source </li>
                    </ul>
                </ul>
            </section>
        </section>

        <section> 
                <h2> There is much more! </h2>
                <p> Look at BlockDriver struct in include/block/block_int.h </p>
        </section>

        <section>
            <h1>THE END</h1>
            <h3>Jeff Cody | Red Hat, Inc.</h3>
        </section>

    </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>

// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: true,
progress: true,
history: true,
center: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

parallaxBackgroundImage: '../resources/images/jeffcody-droplet_0893-3700x2081.JPG',
parallaxBackgroundSize: '3700px 2081px',

// Optional libraries used to extend on reveal.js
//     { src: 'http://revealjs.jit.su/socket.io/socket.io.js', async: true }, 
dependencies: [
     { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
     { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
     { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
     { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
     { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
     { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
     { src: 'plugin/multiplex/client.js', async: true },
     { src: 'plugin/multiplex/master.js', async: true }
     ]
});

</script>

</body>
</html>
